# Copyright 2014 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//base/android/linker/config.gni")
import("//build/config/android/config.gni")
import("//build/config/android/internal_rules.gni")
import("//build/toolchain/toolchain.gni")
import("//third_party/android_platform/config.gni")
import("//tools/grit/grit_rule.gni")

assert(is_android)

# Declare a jni target
#
# This target generates the native jni bindings for a set of .java files.
#
# See base/android/jni_generator/jni_generator.py for more info about the
# format of generating JNI bindings.
#
# Variables
#   sources: list of .java files to generate jni for
#   jni_package: subdirectory path for generated bindings
#
# Example
#   generate_jni("foo_jni") {
#     sources = [
#       "android/java/src/org/chromium/foo/Foo.java",
#       "android/java/src/org/chromium/foo/FooUtil.java",
#     ]
#     jni_package = "foo"
#   }
template("generate_jni") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  assert(defined(invoker.sources))
  assert(defined(invoker.jni_package))
  jni_package = invoker.jni_package
  base_output_dir = "${target_gen_dir}/${target_name}"
  package_output_dir = "${base_output_dir}/${jni_package}"
  jni_output_dir = "${package_output_dir}/jni"

  jni_generator_include = "//base/android/jni_generator/jni_generator_helper.h"

  foreach_target_name = "${target_name}__jni_gen"
  action_foreach(foreach_target_name) {
    script = "//base/android/jni_generator/jni_generator.py"
    depfile = "$target_gen_dir/$target_name.{{source_name_part}}.d"
    sources = invoker.sources
    outputs = [
      depfile,
      "${jni_output_dir}/{{source_name_part}}_jni.h",
    ]

    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--input_file={{source}}",
      "--optimize_generation=1",
      "--ptr_type=long",
      "--output_dir",
      rebase_path(jni_output_dir, root_build_dir),
      "--includes",
      rebase_path(jni_generator_include, jni_output_dir),
      "--native_exports_optional",
    ]
    if (defined(invoker.jni_generator_jarjar_file)) {
      args += [
        "--jarjar",
        rebase_path(jni_generator_jarjar_file, root_build_dir),
      ]
    }
  }

  config("jni_includes_${target_name}") {
    # TODO(cjhopman): #includes should probably all be relative to
    # base_output_dir. Remove that from this config once the includes are
    # updated.
    include_dirs = [
      base_output_dir,
      package_output_dir,
    ]
  }

  group(target_name) {
    public_deps = []
    forward_variables_from(invoker,
                           [
                             "deps",
                             "public_deps",
                             "visibility",
                           ])
    public_deps += [ ":$foreach_target_name" ]
    public_configs = [ ":jni_includes_${target_name}" ]
  }
}

# Declare a jni target for a prebuilt jar
#
# This target generates the native jni bindings for a set of classes in a .jar.
#
# See base/android/jni_generator/jni_generator.py for more info about the
# format of generating JNI bindings.
#
# Variables
#   classes: list of .class files in the jar to generate jni for. These should
#     include the full path to the .class file.
#   jni_package: subdirectory path for generated bindings
#   jar_file: the path to the .jar. If not provided, will default to the sdk's
#     android.jar
#
#   deps, public_deps: As normal
#
# Example
#   generate_jar_jni("foo_jni") {
#     classes = [
#       "android/view/Foo.class",
#     ]
#     jni_package = "foo"
#   }
template("generate_jar_jni") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  assert(defined(invoker.classes))
  assert(defined(invoker.jni_package))

  if (defined(invoker.jar_file)) {
    jar_file = invoker.jar_file
  } else {
    jar_file = android_sdk_jar
  }

  jni_package = invoker.jni_package
  base_output_dir = "${root_gen_dir}/${target_name}/${jni_package}"
  jni_output_dir = "${base_output_dir}/jni"

  jni_generator_include = "//base/android/jni_generator/jni_generator_helper.h"

  # TODO(cjhopman): make jni_generator.py support generating jni for multiple
  # .class files from a .jar.
  jni_actions = []
  foreach(class, invoker.classes) {
    _classname_list = []
    _classname_list = process_file_template([ class ], "{{source_name_part}}")
    classname = _classname_list[0]
    jni_target_name = "${target_name}__jni_${classname}"
    jni_actions += [ ":$jni_target_name" ]
    action(jni_target_name) {
      # The sources aren't compiled so don't check their dependencies.
      check_includes = false
      depfile = "$target_gen_dir/$target_name.d"
      script = "//base/android/jni_generator/jni_generator.py"
      sources = [
        jar_file,
      ]
      outputs = [
        depfile,
        "${jni_output_dir}/${classname}_jni.h",
      ]

      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--jar_file",
        rebase_path(jar_file, root_build_dir),
        "--input_file",
        class,
        "--optimize_generation=1",
        "--ptr_type=long",
        "--output_dir",
        rebase_path(jni_output_dir, root_build_dir),
        "--includes",
        rebase_path(jni_generator_include, jni_output_dir),
        "--native_exports_optional",
      ]
    }
  }

  config("jni_includes_${target_name}") {
    include_dirs = [ base_output_dir ]
  }

  group(target_name) {
    public_deps = []
    forward_variables_from(invoker,
                           [
                             "deps",
                             "public_deps",
                             "visibility",
                           ])
    public_deps += jni_actions
    public_configs = [ ":jni_includes_${target_name}" ]
  }
}

# Declare a target for c-preprocessor-generated java files
#
# NOTE: For generating Java conterparts to enums prefer using the java_cpp_enum
#       rule instead.
#
# This target generates java files using the host C pre-processor. Each file in
# sources will be compiled using the C pre-processor. If include_path is
# specified, it will be passed (with --I) to the pre-processor.
#
# This target will create a single .srcjar. Adding this target to an
# android_library target's srcjar_deps will make the generated java files be
# included in that library's final outputs.
#
# Variables
#   sources: list of files to be processed by the C pre-processor. For each
#     file in sources, there will be one .java file in the final .srcjar. For a
#     file named FooBar.template, a java file will be created with name
#     FooBar.java.
#   inputs: additional compile-time dependencies. Any files
#     `#include`-ed in the templates should be listed here.
#   package_name: this will be the subdirectory for each .java file in the
#     .srcjar.
#
# Example
#   java_cpp_template("foo_generated_enum") {
#     sources = [
#       "android/java/templates/Foo.template",
#     ]
#     inputs = [
#       "android/java/templates/native_foo_header.h",
#     ]
#
#     package_name = "org/chromium/base/library_loader"
#     include_path = "android/java/templates"
#   }
template("java_cpp_template") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  assert(defined(invoker.sources))
  package_name = invoker.package_name + ""

  if (defined(invoker.include_path)) {
    include_path = invoker.include_path + ""
  } else {
    include_path = "//"
  }

  apply_gcc_target_name = "${target_name}__apply_gcc"
  zip_srcjar_target_name = "${target_name}__zip_srcjar"
  final_target_name = target_name

  action_foreach(apply_gcc_target_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "public_deps",
                             "data_deps",
                           ])
    visibility = [ ":$zip_srcjar_target_name" ]
    script = "//build/android/gyp/gcc_preprocess.py"
    if (defined(invoker.inputs)) {
      inputs = invoker.inputs + []
    }
    depfile = "${target_gen_dir}/${target_name}_{{source_name_part}}.d"

    sources = invoker.sources

    gen_dir =
        "${target_gen_dir}/${target_name}/java_cpp_template/${package_name}"
    gcc_template_output_pattern = "${gen_dir}/{{source_name_part}}.java"

    outputs = [
      depfile,
      gcc_template_output_pattern,
    ]

    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--include-path",
      rebase_path(include_path, root_build_dir),
      "--output",
      rebase_path(gen_dir, root_build_dir) + "/{{source_name_part}}.java",
      "--template={{source}}",
    ]

    if (defined(invoker.defines)) {
      foreach(def, invoker.defines) {
        args += [
          "--defines",
          def,
        ]
      }
    }
  }

  apply_gcc_outputs = get_target_outputs(":$apply_gcc_target_name")
  base_gen_dir = get_label_info(":$apply_gcc_target_name", "target_gen_dir")

  srcjar_path = "${target_gen_dir}/${target_name}.srcjar"
  zip(zip_srcjar_target_name) {
    visibility = [ ":$final_target_name" ]
    inputs = apply_gcc_outputs
    output = srcjar_path
    base_dir = base_gen_dir
    deps = [
      ":$apply_gcc_target_name",
    ]
  }

  group(final_target_name) {
    forward_variables_from(invoker, [ "visibility" ])
    public_deps = [
      ":$zip_srcjar_target_name",
    ]
  }
}

# Declare a target for generating Java classes from C++ enums.
#
# This target generates Java files from C++ enums using a script.
#
# This target will create a single .srcjar. Adding this target to an
# android_library target's srcjar_deps will make the generated java files be
# included in that library's final outputs.
#
# Variables
#   sources: list of files to be processed by the script. For each annotated
#     enum contained in the sources files the script will generate a .java
#     file with the same name as the name of the enum.
#
# Example
#   java_cpp_enum("foo_generated_enum") {
#     sources = [
#       "src/native_foo_header.h",
#     ]
#   }
template("java_cpp_enum") {
  action(target_name) {
    # The sources aren't compiled so don't check their dependencies.
    check_includes = false
    set_sources_assignment_filter([])

    assert(defined(invoker.sources))
    forward_variables_from(invoker,
                           [
                             "sources",
                             "testonly",
                             "visibility",
                           ])

    script = "//build/android/gyp/java_cpp_enum.py"
    depfile = "$target_gen_dir/$target_name.d"

    _srcjar_path = "${target_gen_dir}/${target_name}.srcjar"
    _rebased_srcjar_path = rebase_path(_srcjar_path, root_build_dir)
    _rebased_sources = rebase_path(invoker.sources, root_build_dir)

    args = [
             "--depfile",
             rebase_path(depfile, root_build_dir),
             "--srcjar=$_rebased_srcjar_path",
           ] + _rebased_sources
    outputs = [
      depfile,
      _srcjar_path,
    ]
  }
}

# Declare a target for processing a Jinja template.
#
# Variables
#   input: The template file to be processed.
#   output: Where to save the result.
#   variables: (Optional) A list of variables to make available to the template
#     processing environment, e.g. ["name=foo", "color=red"].
#
# Example
#   jinja_template("chrome_public_manifest") {
#     input = "java/AndroidManifest.xml"
#     output = "$target_gen_dir/AndroidManifest.xml"
#   }
template("jinja_template") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  assert(defined(invoker.input))
  assert(defined(invoker.output))

  action(target_name) {
    forward_variables_from(invoker, [ "visibility" ])

    sources = [
      invoker.input,
    ]
    script = "//build/android/gyp/jinja_template.py"
    depfile = "$target_gen_dir/$target_name.d"

    outputs = [
      depfile,
      invoker.output,
    ]

    args = [
      "--inputs",
      rebase_path(invoker.input, root_build_dir),
      "--output",
      rebase_path(invoker.output, root_build_dir),
      "--depfile",
      rebase_path(depfile, root_build_dir),
    ]
    if (defined(invoker.variables)) {
      variables = invoker.variables
      args += [ "--variables=${variables}" ]
    }
  }
}

# Declare a target for processing Android resources as Jinja templates.
#
# This takes an Android resource directory where each resource is a Jinja
# template, processes each template, then packages the results in a zip file
# which can be consumed by an android resources, library, or apk target.
#
# If this target is included in the deps of an android resources/library/apk,
# the resources will be included with that target.
#
# Variables
#   resources: The list of resources files to process.
#   res_dir: The resource directory containing the resources.
#   variables: (Optional) A list of variables to make available to the template
#     processing environment, e.g. ["name=foo", "color=red"].
#
# Example
#   jinja_template_resources("chrome_public_template_resources") {
#     res_dir = "res_template"
#     resources = ["res_template/xml/syncable.xml"]
#     variables = ["color=red"]
#   }
template("jinja_template_resources") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  assert(defined(invoker.resources))
  assert(defined(invoker.res_dir))

  _base_path = "$target_gen_dir/$target_name"
  _resources_zip = _base_path + ".resources.zip"
  _build_config = _base_path + ".build_config"

  write_build_config("${target_name}__build_config") {
    build_config = _build_config
    resources_zip = _resources_zip
    type = "android_resources"
  }

  action("${target_name}__template") {
    sources = invoker.resources
    script = "//build/android/gyp/jinja_template.py"
    depfile = "$target_gen_dir/$target_name.d"

    outputs = [
      depfile,
      _resources_zip,
    ]

    rebased_resources = rebase_path(invoker.resources, root_build_dir)
    args = [
      "--inputs=${rebased_resources}",
      "--inputs-base-dir",
      rebase_path(invoker.res_dir, root_build_dir),
      "--outputs-zip",
      rebase_path(_resources_zip, root_build_dir),
      "--depfile",
      rebase_path(depfile, root_build_dir),
    ]
    if (defined(invoker.variables)) {
      variables = invoker.variables
      args += [ "--variables=${variables}" ]
    }
  }

  group(target_name) {
    public_deps = [
      ":${target_name}__build_config",
      ":${target_name}__template",
    ]
  }
}

# Creates a resources.zip with locale.pak files placed into appropriate
# resource configs (e.g. en-GB.pak -> res/raw-en/en_gb.pak). Also generates
# a locale_paks TypedArray so that resource files can be enumerated at runtime.
#
# If this target is included in the deps of an android resources/library/apk,
# the resources will be included with that target.
#
# Variables:
#   sources: List of .pak files. Names must be of the form "en.pak" or
#       "en-US.pak".
#   deps: (optional) List of dependencies that might be needed to generate
#       the .pak files.
#
# Example
#   locale_pak_resources("locale_paks") {
#     sources = [ "path/en-US.pak", "path/fr.pak", ... ]
#   }
template("locale_pak_resources") {
  set_sources_assignment_filter([])
  assert(defined(invoker.sources))

  _base_path = "$target_gen_dir/$target_name"
  _resources_zip = _base_path + ".resources.zip"
  _build_config = _base_path + ".build_config"

  write_build_config("${target_name}__build_config") {
    build_config = _build_config
    resources_zip = _resources_zip
    type = "android_resources"
  }

  action("${target_name}__create_resources_zip") {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "sources",
                           ])
    script = "//build/android/gyp/locale_pak_resources.py"
    depfile = "$target_gen_dir/$target_name.d"

    outputs = [
      depfile,
      _resources_zip,
    ]

    _rebased_sources = rebase_path(sources, root_build_dir)
    args = [
      "--locale-paks=${_rebased_sources}",
      "--resources-zip",
      rebase_path(_resources_zip, root_build_dir),
      "--depfile",
      rebase_path(depfile, root_build_dir),
    ]
  }

  group(target_name) {
    public_deps = [
      ":${target_name}__build_config",
      ":${target_name}__create_resources_zip",
    ]
  }
}

# Declare an Android resources target
#
# This creates a resources zip file that will be used when building an Android
# library or apk and included into a final apk.
#
# To include these resources in a library/apk, this target should be listed in
# the library's deps. A library/apk will also include any resources used by its
# own dependencies.
#
# Variables
#   deps: Specifies the dependencies of this target. Any Android resources
#     listed in deps will be included by libraries/apks that depend on this
#     target.
#   resource_dirs: List of directories containing resources for this target.
#   android_manifest: AndroidManifest.xml for this target. Defaults to
#     //build/android/AndroidManifest.xml.
#   custom_package: java package for generated .java files.
#   v14_skip: If true, don't run v14 resource generator on this. Defaults to
#     false. (see build/android/gyp/generate_v14_compatible_resources.py)
#
#   shared_resources: If true make a resource package that can be loaded by a
#     different application at runtime to access the package's resources.
#

# Example:
#   android_resources("foo_resources") {
#     deps = [":foo_strings_grd"]
#     resource_dirs = ["res"]
#     custom_package = "org.chromium.foo"
#   }
#
#   android_resources("foo_resources_overrides") {
#     deps = [":foo_resources"]
#     resource_dirs = ["res_overrides"]
#   }
template("android_resources") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  assert(defined(invoker.resource_dirs))

  base_path = "$target_gen_dir/$target_name"
  zip_path = base_path + ".resources.zip"
  srcjar_path = base_path + ".srcjar"
  r_text_path = base_path + "_R.txt"
  build_config = base_path + ".build_config"

  build_config_target_name = "${target_name}__build_config"
  process_resources_target_name = "${target_name}__process_resources"
  final_target_name = target_name

  write_build_config(build_config_target_name) {
    forward_variables_from(invoker,
                           [
                             "android_manifest",
                             "custom_package",
                             "deps",
                           ])

    # No package means resources override their deps.
    if (defined(custom_package) || defined(android_manifest)) {
      r_text = r_text_path
    } else {
      assert(defined(invoker.deps),
             "Must specify deps when custom_package is omitted.")
    }
    visibility = [ ":$process_resources_target_name" ]

    type = "android_resources"
    resources_zip = zip_path
    srcjar = srcjar_path
  }

  process_resources(process_resources_target_name) {
    visibility = [ ":$final_target_name" ]
    deps = []
    forward_variables_from(invoker,
                           [
                             "android_manifest",
                             "custom_package",
                             "deps",
                             "resource_dirs",
                             "shared_resources",
                             "v14_skip",
                           ])
    deps += [ ":$build_config_target_name" ]

    # Always generate R.onResourcesLoaded() method, it is required for
    # compiling ResourceRewriter, there is no side effect because the
    # generated R.class isn't used in final apk.
    shared_resources = true
    if (!defined(android_manifest)) {
      android_manifest = "//build/android/AndroidManifest.xml"
    }
  }

  group(final_target_name) {
    forward_variables_from(invoker, [ "visibility" ])
    public_deps = [
      ":${target_name}__process_resources",
    ]
  }
}

# Declare an Android assets target.
#
# Defines a set of files to include as assets in a dependent apk.
#
# To include these assets in an apk, this target should be listed in
# the apk's deps, or in the deps of a library target used by an apk.
#
# Variables
#   deps: Specifies the dependencies of this target. Any Android assets
#     listed in deps will be included by libraries/apks that depend on this
#     target.
#   sources: List of files to include as assets.
#   renaming_sources: List of files to include as assets and be renamed.
#   renaming_destinations: List of asset paths for files in renaming_sources.
#   disable_compression: Whether to disable compression for files that are
#     known to be compressable (default: false).
#
# Example:
# android_assets("content_shell_assets") {
#   deps = [
#     ":generates_foo",
#     ":other_assets",
#     ]
#   sources = [
#     "//path/asset1.png",
#     "//path/asset2.png",
#     "$target_gen_dir/foo.dat",
#   ]
# }
#
# android_assets("overriding_content_shell_assets") {
#   deps = [ ":content_shell_assets" ]
#   # Override foo.dat from content_shell_assets.
#   sources = [ "//custom/foo.dat" ]
#   renaming_sources = [ "//path/asset2.png" ]
#   renaming_destinations = [ "renamed/asset2.png" ]
# }
template("android_assets") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  _build_config = "$target_gen_dir/$target_name.build_config"
  _build_config_target_name = "${target_name}__build_config"

  write_build_config(_build_config_target_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "disable_compression",
                           ])
    type = "android_assets"
    build_config = _build_config
    if (defined(invoker.sources)) {
      asset_sources = invoker.sources
    }
    if (defined(invoker.renaming_sources)) {
      assert(defined(invoker.renaming_destinations))
      _source_count = 0
      foreach(_, invoker.renaming_sources) {
        _source_count += 1
      }
      _dest_count = 0
      foreach(_, invoker.renaming_destinations) {
        _dest_count += 1
      }
      assert(
          _source_count == _dest_count,
          "android_assets() renaming_sources.length != renaming_destinations.length")
      asset_renaming_sources = invoker.renaming_sources
      asset_renaming_destinations = invoker.renaming_destinations
    }
  }

  group(target_name) {
    forward_variables_from(invoker, [ "visibility" ])
    public_deps = [
      ":$_build_config_target_name",
    ]
  }
}

# Declare a target that generates localized strings.xml from a .grd file.
#
# If this target is included in the deps of an android resources/library/apk,
# the strings.xml will be included with that target.
#
# Variables
#   deps: Specifies the dependencies of this target.
#   grd_file: Path to the .grd file to generate strings.xml from.
#   outputs: Expected grit outputs (see grit rule).
#
# Example
#  java_strings_grd("foo_strings_grd") {
#    grd_file = "foo_strings.grd"
#  }
template("java_strings_grd") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  base_path = "$target_gen_dir/$target_name"
  resources_zip = base_path + ".resources.zip"
  build_config = base_path + ".build_config"

  write_build_config("${target_name}__build_config") {
    forward_variables_from(invoker, [ "deps" ])
    type = "android_resources"
  }

  # Put grit files into this subdirectory of target_gen_dir.
  extra_output_path = target_name + "_grit_output"

  grit_target_name = "${target_name}__grit"
  grit_output_dir = "$target_gen_dir/$extra_output_path"
  grit(grit_target_name) {
    grit_flags = [
      "-E",
      "ANDROID_JAVA_TAGGED_ONLY=false",
    ]
    output_dir = grit_output_dir
    resource_ids = ""
    source = invoker.grd_file
    outputs = invoker.outputs
  }

  # This needs to get outputs from grit's internal target, not the final
  # source_set.
  generate_strings_outputs = get_target_outputs(":${grit_target_name}_grit")

  zip("${target_name}__zip") {
    base_dir = grit_output_dir
    inputs = generate_strings_outputs
    output = resources_zip
    deps = [
      ":$grit_target_name",
    ]
  }

  group(target_name) {
    public_deps = [
      ":${target_name}__build_config",
      ":${target_name}__zip",
    ]
  }
}

# Declare a target that packages strings.xml generated from a grd file.
#
# If this target is included in the deps of an android resources/library/apk,
# the strings.xml will be included with that target.
#
# Variables
#  grit_output_dir: directory containing grit-generated files.
#  generated_files: list of android resource files to package.
#
# Example
#  java_strings_grd_prebuilt("foo_strings_grd") {
#    grit_output_dir = "$root_gen_dir/foo/grit"
#    generated_files = [
#      "values/strings.xml"
#    ]
#  }
template("java_strings_grd_prebuilt") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  base_path = "$target_gen_dir/$target_name"
  resources_zip = base_path + ".resources.zip"
  build_config = base_path + ".build_config"

  build_config_target_name = "${target_name}__build_config"
  zip_target_name = "${target_name}__zip"
  final_target_name = target_name

  write_build_config(build_config_target_name) {
    visibility = [ ":$zip_target_name" ]
    type = "android_resources"
  }

  zip(zip_target_name) {
    visibility = [ ":$final_target_name" ]

    base_dir = invoker.grit_output_dir
    inputs = rebase_path(invoker.generated_files, ".", base_dir)
    output = resources_zip
    deps = [
      ":$build_config_target_name",
    ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }

  group(final_target_name) {
    forward_variables_from(invoker, [ "visibility" ])
    public_deps = [
      ":$zip_target_name",
    ]
  }
}

# Declare a Java executable target
#
# This target creates an executable from java code and libraries. The executable
# will be in the output folder's /bin/ directory.
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be included in the executable (and the javac classpath).
#   java_files: List of .java files included in this library.
#   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
#     will be added to java_files and be included in this library.
#   srcjars: List of srcjars to be included in this library, together with the
#     ones obtained from srcjar_deps.
#   bypass_platform_checks: Disables checks about cross-platform (Java/Android)
#     dependencies for this target. This will allow depending on an
#     android_library target, for example.
#   chromium_code: If true, extra analysis warning/errors will be enabled.
#   enable_errorprone: If true, enables the errorprone compiler.
#   enable_incremental_javac: Overrides the global enable_incremental_javac.
#   main_class: When specified, a wrapper script is created within
#     $target_out_dir/bin to launch the binary with the given class as the
#     entrypoint.
#   wrapper_script_args: List of additional arguments for the wrapper script.
#
#   data_deps, testonly
#
# Example
#   java_binary("foo") {
#     java_files = [ "org/chromium/foo/FooMain.java" ]
#     deps = [ ":bar_java" ]
#     main_class = "org.chromium.foo.FooMain"
#   }
template("java_binary") {
  set_sources_assignment_filter([])

  # TODO(cjhopman): This should not act like a java_library for dependents (i.e.
  # dependents shouldn't get the jar in their classpath, etc.).
  java_library_impl(target_name) {
    forward_variables_from(invoker, "*")
    supports_android = false
    main_class = invoker.main_class
  }
}

# Declare a Junit executable target
#
# This target creates an executable from java code for running as a junit test
# suite. The executable will be in the output folder's /bin/ directory.
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be included in the executable (and the javac classpath).
#
#   java_files: List of .java files included in this library.
#   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
#     will be added to java_files and be included in this library.
#   srcjars: List of srcjars to be included in this library, together with the
#     ones obtained from srcjar_deps.
#
#   chromium_code: If true, extra analysis warning/errors will be enabled.
#
# Example
#   junit_binary("foo") {
#     java_files = [ "org/chromium/foo/FooTest.java" ]
#     deps = [ ":bar_java" ]
#   }
template("junit_binary") {
  set_sources_assignment_filter([])

  java_binary(target_name) {
    deps = []
    forward_variables_from(invoker, "*")
    bypass_platform_checks = true
    main_class = "org.chromium.testing.local.JunitTestMain"
    wrapper_script_args = [
      "-test-jars",
      "$target_name.jar",
    ]
    testonly = true

    deps += [
      "//testing/android/junit:junit_test_support",
      "//third_party/junit",
      "//third_party/mockito:mockito_java",
      "//third_party/robolectric:android-all-4.3_r2-robolectric-0",
      "//third_party/robolectric:robolectric_java",
    ]
  }
}

# Declare a java library target
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be added to the javac classpath.
#
#   java_files: List of .java files included in this library.
#   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
#     will be added to java_files and be included in this library.
#   srcjars: List of srcjars to be included in this library, together with the
#     ones obtained from srcjar_deps.
#   DEPRECATED_java_in_dir: Directory containing java files. All .java files in
#     this directory will be included in the library. This is only supported to
#     ease the gyp->gn conversion and will be removed in the future.
#
#   chromium_code: If true, extra analysis warning/errors will be enabled.
#   enable_errorprone: If true, enables the errorprone compiler.
#   enable_incremental_javac: Overrides the global enable_incremental_javac.
#
#   jar_excluded_patterns: List of patterns of .class files to exclude from the
#     final jar.
#
#   proguard_preprocess: If true, proguard preprocessing will be run. This can
#     be used to remove unwanted parts of the library.
#   proguard_config: Path to the proguard config for preprocessing.
#
#   supports_android: If true, Android targets (android_library, android_apk)
#     may depend on this target. Note: if true, this target must only use the
#     subset of Java available on Android.
#   bypass_platform_checks: Disables checks about cross-platform (Java/Android)
#     dependencies for this target. This will allow depending on an
#     android_library target, for example.
#
#   data_deps, testonly
#
# Example
#   java_library("foo_java") {
#     java_files = [
#       "org/chromium/foo/Foo.java",
#       "org/chromium/foo/FooInterface.java",
#       "org/chromium/foo/FooService.java",
#     ]
#     deps = [
#       ":bar_java"
#     ]
#     srcjar_deps = [
#       ":foo_generated_enum"
#     ]
#     jar_excluded_patterns = [
#       "*/FooService.class", "*/FooService##*.class"
#     ]
#   }
template("java_library") {
  set_sources_assignment_filter([])
  java_library_impl(target_name) {
    forward_variables_from(invoker, "*")
  }
}

# Declare a java library target for a prebuilt jar
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be added to the javac classpath.
#   jar_path: Path to the prebuilt jar.
#   jar_dep: Target that builds jar_path (optional).
#   proguard_preprocess: If true, proguard preprocessing will be run. This can
#     be used to remove unwanted parts of the library.
#   proguard_config: Path to the proguard config for preprocessing.
#   supports_android: If true, Android targets (android_library, android_apk)
#     may depend on this target. Note: if true, this target must only use the
#     subset of Java available on Android.
#
# Example
#   java_prebuilt("foo_java") {
#     jar_path = "foo.jar"
#     deps = [
#       ":foo_resources",
#       ":bar_java"
#     ]
#   }
template("java_prebuilt") {
  set_sources_assignment_filter([])
  java_prebuilt_impl(target_name) {
    forward_variables_from(invoker, "*")
  }
}

# Declare an Android library target
#
# This target creates an Android library containing java code and Android
# resources.
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be added to the javac classpath. Android resources in dependencies
#     will be used when building this library.
#
#   java_files: List of .java files included in this library.
#   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
#     will be added to java_files and be included in this library.
#   srcjars: List of srcjars to be included in this library, together with the
#     ones obtained from srcjar_deps.
#   DEPRECATED_java_in_dir: Directory containing java files. All .java files in
#     this directory will be included in the library. This is only supported to
#     ease the gyp->gn conversion and will be removed in the future.
#
#   chromium_code: If true, extra analysis warning/errors will be enabled.
#   enable_errorprone: If true, enables the errorprone compiler.
#   enable_incremental_javac: Overrides the global enable_incremental_javac.
#
#   jar_excluded_patterns: List of patterns of .class files to exclude from the
#     final jar.
#
#   proguard_preprocess: If true, proguard preprocessing will be run. This can
#     be used to remove unwanted parts of the library.
#   proguard_config: Path to the proguard config for preprocessing.
#
#   dex_path: If set, the resulting .dex.jar file will be placed under this
#     path.
#
#   alternative_android_sdk_ijar: if set, the given android_sdk_ijar file
#     replaces the default android_sdk_ijar.
#
#   alternative_android_sdk_ijar_dep: the target that generates
#      alternative_android_sdk_ijar, must be set if alternative_android_sdk_ijar
#      is used.
#
#   emma_never_instrument: Disables EMMA Java code coverage for this target.
#
# Example
#   android_library("foo_java") {
#     java_files = [
#       "android/org/chromium/foo/Foo.java",
#       "android/org/chromium/foo/FooInterface.java",
#       "android/org/chromium/foo/FooService.java",
#     ]
#     deps = [
#       ":bar_java"
#     ]
#     srcjar_deps = [
#       ":foo_generated_enum"
#     ]
#     jar_excluded_patterns = [
#       "*/FooService.class", "*/FooService##*.class"
#     ]
#   }
template("android_library") {
  set_sources_assignment_filter([])
  assert(!defined(invoker.jar_path),
         "android_library does not support a custom jar path")

  if (defined(invoker.alternative_android_sdk_ijar)) {
    assert(defined(invoker.alternative_android_sdk_ijar_dep))
  }

  java_library_impl(target_name) {
    forward_variables_from(invoker, "*")

    supports_android = true
    requires_android = true

    if (!defined(jar_excluded_patterns)) {
      jar_excluded_patterns = []
    }
    jar_excluded_patterns += [
      "*/R.class",
      "*/R##*.class",
      "*/Manifest.class",
      "*/Manifest##*.class",
    ]
  }
}

# Declare a target that packages a set of Java dependencies into a standalone
# .dex.jar.
#
# Variables
#   deps: specifies the dependencies of this target. Android libraries in deps
#     will be packaged into the resulting .dex.jar file.
#   dex_path: location at which the output file will be put
template("android_standalone_library") {
  set_sources_assignment_filter([])
  deps_dex(target_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "dex_path",
                             "excluded_jars",
                           ])
  }
}

# Declare an Android library target for a prebuilt jar
#
# This target creates an Android library containing java code and Android
# resources.
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be added to the javac classpath. Android resources in dependencies
#     will be used when building this library.
#   jar_path: Path to the prebuilt jar.
#   proguard_preprocess: If true, proguard preprocessing will be run. This can
#     be used to remove unwanted parts of the library.
#   proguard_config: Path to the proguard config for preprocessing.
#
# Example
#   android_java_prebuilt("foo_java") {
#     jar_path = "foo.jar"
#     deps = [
#       ":foo_resources",
#       ":bar_java"
#     ]
#   }
template("android_java_prebuilt") {
  set_sources_assignment_filter([])
  java_prebuilt_impl(target_name) {
    forward_variables_from(invoker, "*")
    supports_android = true
    requires_android = true
  }
}

# Declare an Android apk target
#
# This target creates an Android APK containing java code, resources, assets,
# and (possibly) native libraries.
#
# Variables
#   android_manifest: Path to AndroidManifest.xml.
#   android_manifest_dep: Target that generates AndroidManifest (if applicable)
#   chromium_code: If true, extra analysis warning/errors will be enabled.
#   data_deps: List of dependencies needed at runtime. These will be built but
#     won't change the generated .apk in any way (in fact they may be built
#     after the .apk is).
#   deps: List of dependencies. All Android java resources and libraries in the
#     "transitive closure" of these dependencies will be included in the apk.
#     Note: this "transitive closure" actually only includes such targets if
#     they are depended on through android_library or android_resources targets
#     (and so not through builtin targets like 'action', 'group', etc).
#   java_files: List of .java files to include in the apk.
#   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
#      will be added to java_files and be included in this apk.
#   apk_name: Name for final apk.
#   final_apk_path: Path to final built apk. Default is
#     $root_out_dir/apks/$apk_name.apk. Setting this will override apk_name.
#   native_libs: List paths of native libraries to include in this apk. If these
#     libraries depend on other shared_library targets, those dependencies will
#     also be included in the apk.
#   native_lib_placeholders: List of placeholder filenames to add to the apk
#     (optional).
#   apk_under_test: For an instrumentation test apk, this is the target of the
#     tested apk.
#   include_all_resources - If true include all resource IDs in all generated
#     R.java files.
#   testonly: Marks this target as "test-only".
#   write_asset_list: Adds an extra file to the assets, which contains a list of
#     all other asset files.
#
#   DEPRECATED_java_in_dir: Directory containing java files. All .java files in
#     this directory will be included in the library. This is only supported to
#     ease the gyp->gn conversion and will be removed in the future.
#
# Example
#   android_apk("foo_apk") {
#     android_manifest = "AndroidManifest.xml"
#     java_files = [
#       "android/org/chromium/foo/FooApplication.java",
#       "android/org/chromium/foo/FooActivity.java",
#     ]
#     deps = [
#       ":foo_support_java"
#       ":foo_resources"
#     ]
#     srcjar_deps = [
#       ":foo_generated_enum"
#     ]
#     native_libs = [
#       native_lib_path
#     ]
#   }
template("android_apk") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  assert(defined(invoker.final_apk_path) || defined(invoker.apk_name))
  assert(defined(invoker.android_manifest))
  gen_dir = "$target_gen_dir/$target_name"
  base_path = "$gen_dir/$target_name"
  _build_config = "$target_gen_dir/$target_name.build_config"
  resources_zip_path = "$base_path.resources.zip"
  _all_resources_zip_path = "$base_path.resources.all.zip"
  _jar_path = "$base_path.jar"
  _lib_dex_path = "$base_path.dex.jar"
  _rebased_lib_dex_path = rebase_path(_lib_dex_path, root_build_dir)
  _template_name = target_name

  enable_multidex = defined(invoker.enable_multidex) && invoker.enable_multidex
  if (enable_multidex) {
    final_dex_path = "$gen_dir/classes.dex.zip"
  } else {
    final_dex_path = "$gen_dir/classes.dex"
  }
  final_dex_target_name = "${_template_name}__final_dex"

  _final_apk_path = ""
  if (defined(invoker.final_apk_path)) {
    _final_apk_path = invoker.final_apk_path
  } else if (defined(invoker.apk_name)) {
    _final_apk_path = "$root_build_dir/apks/" + invoker.apk_name + ".apk"
  }
  _dist_jar_path_list =
      process_file_template(
          [ _final_apk_path ],
          "$root_build_dir/test.lib.java/{{source_name_part}}.jar")
  _dist_jar_path = _dist_jar_path_list[0]
  _final_apk_path_no_ext_list =
      process_file_template([ _final_apk_path ],
                            "{{source_dir}}/{{source_name_part}}")
  _final_apk_path_no_ext = _final_apk_path_no_ext_list[0]
  assert(_final_apk_path_no_ext != "")  # Mark as used.

  _native_libs = []

  _version_code = "1"
  if (defined(invoker.version_code)) {
    _version_code = invoker.version_code
  }

  _version_name = "Developer Build"
  if (defined(invoker.version_name)) {
    _version_name = invoker.version_name
  }
  _keystore_path = android_keystore_path
  _keystore_name = android_keystore_name
  _keystore_password = android_keystore_password

  if (defined(invoker.keystore_path)) {
    _keystore_path = invoker.keystore_path
    _keystore_name = invoker.keystore_name
    _keystore_password = invoker.keystore_password
  }

  _srcjar_deps = []
  if (defined(invoker.srcjar_deps)) {
    _srcjar_deps += invoker.srcjar_deps
  }

  _use_chromium_linker =
      defined(invoker.use_chromium_linker) && invoker.use_chromium_linker &&
      chromium_linker_supported
  _enable_relocation_packing =
      defined(invoker.enable_relocation_packing) &&
      invoker.enable_relocation_packing && _use_chromium_linker
  _load_library_from_apk =
      defined(invoker.load_library_from_apk) && invoker.load_library_from_apk

  assert(_use_chromium_linker || true)  # Mark as used.
  assert(_enable_relocation_packing || true)  # Mark as used.

  assert(
      !_load_library_from_apk || _use_chromium_linker,
      "Loading library from the apk requires use" + " of the Chromium linker.")

  # The dependency that makes the chromium linker, if any is needed.
  _native_libs_deps = []

  if (defined(invoker.native_libs) && invoker.native_libs != []) {
    if (is_component_build) {
      _native_libs += [ "$root_shlib_dir/libc++_shared.so" ]
      _native_libs_deps += [ "//build/android:cpplib_stripped" ]
    }

    # Allow native_libs to be in the form "foo.so" or "foo.cr.so"
    _first_ext_removed =
        process_file_template(invoker.native_libs, "{{source_name_part}}")
    _native_libs += process_file_template(
            _first_ext_removed,
            "$root_shlib_dir/{{source_name_part}}$shlib_extension")

    _native_lib_version_rule = ""
    if (defined(invoker.native_lib_version_rule)) {
      _native_lib_version_rule = invoker.native_lib_version_rule
    }
    _native_lib_version_arg = "\"\""
    if (defined(invoker.native_lib_version_arg)) {
      _native_lib_version_arg = invoker.native_lib_version_arg
    }
  }

  _android_manifest_deps = []
  if (defined(invoker.android_manifest_dep)) {
    _android_manifest_deps = [ invoker.android_manifest_dep ]
  }
  _android_manifest = invoker.android_manifest

  _rebased_build_config = rebase_path(_build_config, root_build_dir)
  _create_abi_split =
      defined(invoker.create_abi_split) && invoker.create_abi_split
  _create_density_splits =
      defined(invoker.create_density_splits) && invoker.create_density_splits
  _create_language_splits =
      defined(invoker.language_splits) && invoker.language_splits != []

  # Help GN understand that _create_abi_split is not unused (bug in GN).
  assert(_create_abi_split || true)

  _proguard_enabled =
      defined(invoker.proguard_enabled) && invoker.proguard_enabled
  if (_proguard_enabled) {
    _proguard_jar_path = "$base_path.proguard.jar"
  }

  _emma_never_instrument = defined(invoker.testonly) && invoker.testonly

  build_config_target = "${_template_name}__build_config"
  write_build_config(build_config_target) {
    forward_variables_from(invoker, [ "apk_under_test" ])
    type = "android_apk"
    jar_path = _jar_path
    dex_path = final_dex_path
    apk_path = _final_apk_path
    resources_zip = resources_zip_path
    build_config = _build_config
    android_manifest = _android_manifest

    deps = _native_libs_deps + _android_manifest_deps
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }

    proguard_enabled = _proguard_enabled
    if (_proguard_enabled) {
      proguard_info = "$_proguard_jar_path.info"
    }

    native_libs = _native_libs
  }

  _final_deps = []

  _generated_proguard_config = "$base_path.resources.proguard.txt"
  process_resources_target = "${_template_name}__process_resources"
  process_resources(process_resources_target) {
    forward_variables_from(invoker,
                           [
                             "include_all_resources",
                             "shared_resources",
                           ])
    srcjar_path = "${target_gen_dir}/${target_name}.srcjar"
    r_text_path = "${target_gen_dir}/${target_name}_R.txt"
    android_manifest = _android_manifest
    resource_dirs = [ "//build/android/ant/empty/res" ]
    zip_path = resources_zip_path
    all_resources_zip_path = _all_resources_zip_path
    generate_constant_ids = true
    proguard_file = _generated_proguard_config

    build_config = _build_config
    deps = _android_manifest_deps + [ ":$build_config_target" ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }
  _srcjar_deps += [ ":$process_resources_target" ]

  if (_native_libs != []) {
    _enable_chromium_linker_tests = false
    if (defined(invoker.enable_chromium_linker_tests)) {
      _enable_chromium_linker_tests = invoker.enable_chromium_linker_tests
    }

    java_cpp_template("${_template_name}__native_libraries_java") {
      package_name = "org/chromium/base/library_loader"
      sources = [
        "//base/android/java/templates/NativeLibraries.template",
      ]
      inputs = [
        _build_config,
      ]
      deps = [
        ":$build_config_target",
      ]
      if (_native_lib_version_rule != "") {
        deps += [ _native_lib_version_rule ]
      }

      defines = [
        "NATIVE_LIBRARIES_LIST=" +
            "@FileArg($_rebased_build_config:native:java_libraries_list)",
        "NATIVE_LIBRARIES_VERSION_NUMBER=$_native_lib_version_arg",
      ]
      if (_use_chromium_linker) {
        defines += [ "ENABLE_CHROMIUM_LINKER" ]
      }
      if (_load_library_from_apk) {
        defines += [ "ENABLE_CHROMIUM_LINKER_LIBRARY_IN_ZIP_FILE" ]
      }
      if (_enable_chromium_linker_tests) {
        defines += [ "ENABLE_CHROMIUM_LINKER_TESTS" ]
      }
    }
    _srcjar_deps += [ ":${_template_name}__native_libraries_java" ]
  }

  java_target = "${_template_name}__java"
  java_library_impl(java_target) {
    forward_variables_from(invoker, [ "run_findbugs" ])
    supports_android = true
    requires_android = true
    override_build_config = _build_config
    deps = _android_manifest_deps + [ ":$build_config_target" ]

    android_manifest = _android_manifest
    chromium_code = true
    if (defined(invoker.chromium_code)) {
      chromium_code = invoker.chromium_code
    }

    if (defined(invoker.java_files)) {
      java_files = invoker.java_files
    } else if (defined(invoker.DEPRECATED_java_in_dir)) {
      DEPRECATED_java_in_dir = invoker.DEPRECATED_java_in_dir
    } else {
      java_files = []
    }
    srcjar_deps = _srcjar_deps
    jar_path = _jar_path
    dex_path = _lib_dex_path
    emma_never_instrument = _emma_never_instrument

    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }

  if (_dist_jar_path != "") {
    create_dist_target = "${_template_name}__create_dist_jar"
    _final_deps += [ ":$create_dist_target" ]

    # TODO(cjhopman): This is only ever needed to calculate the list of tests to
    # run. See build/android/pylib/instrumentation/test_jar.py. We should be
    # able to just do that calculation at build time instead.
    action(create_dist_target) {
      script = "//build/android/gyp/create_dist_jar.py"
      depfile = "$target_gen_dir/$target_name.d"
      inputs = [
        _build_config,
      ]
      outputs = [
        depfile,
        _dist_jar_path,
      ]
      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--output",
        rebase_path(_dist_jar_path, root_build_dir),
        "--inputs=@FileArg($_rebased_build_config:dist_jar:dependency_jars)",
      ]
      inputs += [ _jar_path ]
      _rebased_jar_path = rebase_path([ _jar_path ], root_build_dir)
      args += [ "--inputs=$_rebased_jar_path" ]
      deps = [
        ":$build_config_target",  # Generates the build config file.
        ":$java_target",  # Generates the jar file.
      ]
    }
  }

  if (_proguard_enabled) {
    _proguard_configs = [ _generated_proguard_config ]
    if (defined(invoker.proguard_configs)) {
      _proguard_configs += invoker.proguard_configs
    }
    _proguard_target = "${_template_name}__proguard"
    proguard(_proguard_target) {
      deps = [
        ":$build_config_target",
        ":$java_target",
        ":$process_resources_target",
      ]
      inputs = [
                 _build_config,
                 _jar_path,
               ] + _proguard_configs

      output_jar_path = _proguard_jar_path
      rebased_proguard_configs = rebase_path(_proguard_configs, root_build_dir)
      args = [
        "--proguard-configs=$rebased_proguard_configs",
        "--tested-apk-info=@FileArg($_rebased_build_config:proguard:tested_apk_info)",
        "--input-paths=@FileArg($_rebased_build_config:proguard:input_paths)",
      ]
    }
    _dex_sources = [ _proguard_jar_path ]
    _dex_deps = [ ":$_proguard_target" ]
  } else {
    if (enable_multidex) {
      _dex_sources = [ _jar_path ]
    } else {
      _dex_sources = [ _lib_dex_path ]
    }
    _dex_deps = [ ":$java_target" ]
  }

  dex("$final_dex_target_name") {
    forward_variables_from(invoker, [ "enable_multidex" ])
    deps = _dex_deps + [ ":$build_config_target" ]
    inputs = [
      _build_config,
    ]
    sources = _dex_sources
    output = final_dex_path

    # All deps are already included in _dex_sources when proguard is used.
    if (!_proguard_enabled) {
      if (enable_multidex) {
        _dex_arg_key = "${_rebased_build_config}:dist_jar:dependency_jars"
      } else {
        _dex_arg_key = "${_rebased_build_config}:final_dex:dependency_dex_files"
      }
      args = [ "--inputs=@FileArg($_dex_arg_key)" ]
    }

    if (emma_coverage && !_emma_never_instrument) {
      no_locals = true
      sources += [ "$android_sdk_root/tools/lib/emma_device.jar" ]
    }
  }

  _native_libs_file_arg_dep = ":$build_config_target"
  _native_libs_file_arg = "@FileArg($_rebased_build_config:native:libraries)"

  if (_native_libs != [] && _enable_relocation_packing) {
    _prepare_native_target_name = "${_template_name}__prepare_native"
    _native_libs_dir = "$gen_dir/packed-libs"
    _native_libs_json = "$gen_dir/packed-libs/filelist.json"
    _rebased_native_libs_json = rebase_path(_native_libs_json, root_build_dir)

    _native_libs_file_arg_dep = ":$_prepare_native_target_name"
    _native_libs_file_arg = "@FileArg($_rebased_native_libs_json:files)"

    action(_prepare_native_target_name) {
      forward_variables_from(invoker,
                             [
                               "deps",
                               "public_deps",
                             ])
      script = "//build/android/gyp/pack_relocations.py"
      depfile = "$target_gen_dir/$target_name.d"
      outputs = [
        depfile,
        _native_libs_json,
      ]

      inputs = _native_libs + [ _build_config ]

      deps += _native_libs_deps
      deps += [
        ":$build_config_target",
        relocation_packer_target,
      ]

      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--enable-packing=1",
        "--android-pack-relocations",
        rebase_path(relocation_packer_exe, root_build_dir),
        "--stripped-libraries-dir",
        rebase_path(root_build_dir, root_build_dir),
        "--packed-libraries-dir",
        rebase_path(_native_libs_dir, root_build_dir),
        "--libraries=@FileArg(${_rebased_build_config}:native:libraries)",
        "--filelistjson=$_rebased_native_libs_json",
      ]
    }
  }

  _extra_native_libs = []
  _extra_native_libs_deps = []
  if (_native_libs != []) {
    _extra_native_libs_even_when_incremental = []
    _extra_native_libs_even_when_incremental_deps = []

    if (is_debug) {
      _extra_native_libs_even_when_incremental = [ android_gdbserver ]
    }

    if (_use_chromium_linker) {
      _extra_native_libs =
          [ "$root_shlib_dir/libchromium_android_linker$shlib_extension" ]
      _extra_native_libs_deps +=
          [ "//base/android/linker:chromium_android_linker" ]
    }
  }

  _final_deps += [ ":${_template_name}__create" ]
  create_apk("${_template_name}__create") {
    deps = []
    forward_variables_from(invoker,
                           [
                             "asset_location",
                             "deps",
                             "extensions_to_not_compress",
                             "language_splits",
                             "public_deps",
                             "shared_resources",
                             "write_asset_list",
                           ])
    apk_path = _final_apk_path
    android_manifest = _android_manifest
    assets_build_config = _build_config
    resources_zip = _all_resources_zip_path
    dex_path = final_dex_path
    load_library_from_apk = _load_library_from_apk
    create_density_splits = _create_density_splits
    emma_instrument = emma_coverage && !_emma_never_instrument

    if (!defined(extensions_to_not_compress)) {
      # Allow icu data, v8 snapshots, and pak files to be loaded directly from
      # the .apk.
      # Note: These are actually suffix matches, not necessarily extensions.
      extensions_to_not_compress = ".dat,.bin,.pak"
    }

    version_code = _version_code
    version_name = _version_name

    keystore_name = _keystore_name
    keystore_path = _keystore_path
    keystore_password = _keystore_password

    # Incremental apk does not use native libs nor final dex.
    incremental_deps = deps + _android_manifest_deps + [
                         ":$build_config_target",
                         ":$process_resources_target",
                       ]

    # This target generates the input file _all_resources_zip_path.
    deps += _android_manifest_deps + [
              ":$build_config_target",
              ":$process_resources_target",
              ":$final_dex_target_name",
            ]

    if (_native_libs != [] && !_create_abi_split) {
      deps += _native_libs_deps + _extra_native_libs_deps +
              _extra_native_libs_even_when_incremental_deps +
              [ _native_libs_file_arg_dep ]
      native_libs_filearg = _native_libs_file_arg
      native_libs = _extra_native_libs
      native_libs_even_when_incremental =
          _extra_native_libs_even_when_incremental

      # Placeholders necessary for some older devices.
      # http://crbug.com/395038
      forward_variables_from(invoker, [ "native_lib_placeholders" ])
    }
  }

  if (_native_libs != [] && _create_abi_split) {
    _manifest_rule = "${_template_name}__split_manifest_abi_${android_app_abi}"
    generate_split_manifest(_manifest_rule) {
      main_manifest = _android_manifest
      out_manifest =
          "$gen_dir/split-manifests/${android_app_abi}/AndroidManifest.xml"
      split_name = "abi_${android_app_abi}"
      deps = _android_manifest_deps
    }

    _apk_rule = "${_template_name}__split_apk_abi_${android_app_abi}"
    _final_deps += [ ":$_apk_rule" ]

    create_apk(_apk_rule) {
      apk_path = "${_final_apk_path_no_ext}-abi-${android_app_abi}.apk"
      base_path = "$gen_dir/$_apk_rule"

      manifest_outputs = get_target_outputs(":${_manifest_rule}")
      android_manifest = manifest_outputs[1]
      load_library_from_apk = _load_library_from_apk

      version_code = _version_code
      version_name = _version_name

      keystore_name = _keystore_name
      keystore_path = _keystore_path
      keystore_password = _keystore_password

      # Placeholders necessary for some older devices.
      # http://crbug.com/395038
      deps = []
      forward_variables_from(invoker,
                             [
                               "deps",
                               "native_lib_placeholders",
                               "public_deps",
                             ])

      incremental_deps = deps + _extra_native_libs_even_when_incremental_deps +
                         [ ":$_manifest_rule" ]
      deps = []
      deps = incremental_deps + _native_libs_deps + _extra_native_libs_deps +
             [ _native_libs_file_arg_dep ]
      native_libs_filearg = _native_libs_file_arg
      native_libs = _extra_native_libs
      native_libs_even_when_incremental =
          _extra_native_libs_even_when_incremental
    }
  }

  _create_incremental_script_rule_name = "${_template_name}__incremental_script"
  action(_create_incremental_script_rule_name) {
    script = "//build/android/incremental_install/create_install_script.py"
    depfile = "$target_gen_dir/$target_name.d"
    deps = [
      _native_libs_file_arg_dep,
    ]

    _generated_script_path =
        "${root_out_dir}/bin/install_${_template_name}_incremental"
    outputs = [
      depfile,
      _generated_script_path,
    ]

    _rebased_apk_path_no_ext =
        rebase_path(_final_apk_path_no_ext, root_build_dir)
    _rebased_generated_script_path =
        rebase_path(_generated_script_path, root_build_dir)
    _rebased_depfile = rebase_path(depfile, root_build_dir)
    _dex_arg_key = "${_rebased_build_config}:final_dex:dependency_dex_files"
    args = [
      "--apk-path=${_rebased_apk_path_no_ext}_incremental.apk",
      "--script-output-path=$_rebased_generated_script_path",
      "--dex-file=$_rebased_lib_dex_path",
      "--dex-file-list=@FileArg($_dex_arg_key)",
      "--depfile=$_rebased_depfile",
    ]
    if (_proguard_enabled) {
      args += [ "--show-proguard-warning" ]
    }
    if (defined(_native_libs_file_arg)) {
      args += [ "--native-libs=$_native_libs_file_arg" ]
    }
    if (_extra_native_libs != []) {
      # Don't pass in _extra_native_libs_even_when_incremental, since these are
      # end up in the apk and are not side-loaded.
      _rebased_extra_native_libs =
          rebase_path(_extra_native_libs, root_build_dir)
      args += [ "--native-libs=$_rebased_extra_native_libs" ]
    }
    if (_create_density_splits) {
      args += [ "--split=${_rebased_apk_path_no_ext}-density-*.apk" ]
    }
    if (_create_language_splits) {
      args += [ "--split=${_rebased_apk_path_no_ext}-language-*.apk" ]
    }
  }

  group(target_name) {
    forward_variables_from(invoker, [ "data_deps" ])
    public_deps = _final_deps
  }
  group("${target_name}_incremental") {
    data_deps = []
    forward_variables_from(invoker, [ "data_deps" ])

    # device/commands is used by the installer script to push files via .zip.
    data_deps += [ "//build/android/pylib/device/commands" ] +
                 _native_libs_deps + _extra_native_libs_deps

    # Since the _incremental.apk does not include use .so nor .dex from the
    # actual target, but instead loads them at runtime, we need to explicitly
    # depend on them here.
    public_deps = [
      ":${_create_incremental_script_rule_name}",
      ":${_template_name}__create_incremental",
      ":${java_target}",
    ]
  }
}

# Declare an Android instrumentation test apk
#
# This target creates an Android instrumentation test apk.
#
# Variables
#   android_manifest: Path to AndroidManifest.xml.
#   data_deps: List of dependencies needed at runtime. These will be built but
#     won't change the generated .apk in any way (in fact they may be built
#     after the .apk is).
#   deps: List of dependencies. All Android java resources and libraries in the
#     "transitive closure" of these dependencies will be included in the apk.
#     Note: this "transitive closure" actually only includes such targets if
#     they are depended on through android_library or android_resources targets
#     (and so not through builtin targets like 'action', 'group', etc).
#   java_files: List of .java files to include in the apk.
#   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
#      will be added to java_files and be included in this apk.
#   apk_name: Name for final apk.
#   final_apk_path: Path to final built apk. Default is
#     $root_out_dir/apks/$apk_name.apk. Setting this will override apk_name.
#   native_libs: List paths of native libraries to include in this apk. If these
#     libraries depend on other shared_library targets, those dependencies will
#     also be included in the apk.
#   apk_under_test: The apk being tested.
#   isolate_file: Isolate file containing the list of test data dependencies.
#
#   DEPRECATED_java_in_dir: Directory containing java files. All .java files in
#     this directory will be included in the library. This is only supported to
#     ease the gyp->gn conversion and will be removed in the future.
#
# Example
#   instrumentation_test_apk("foo_test_apk") {
#     android_manifest = "AndroidManifest.xml"
#     apk_name = "FooTest"
#     apk_under_test = "Foo"
#     java_files = [
#       "android/org/chromium/foo/FooTestCase.java",
#       "android/org/chromium/foo/FooExampleTest.java",
#     ]
#     deps = [
#       ":foo_test_support_java"
#     ]
#   }
template("instrumentation_test_apk") {
  testonly = true
  _apk_target_name = "${target_name}__apk"
  _test_runner_target_name = "${target_name}__test_runner_script"

  test_runner_script(_test_runner_target_name) {
    forward_variables_from(invoker, [ "isolate_file" ])
    test_name = invoker.target_name
    test_type = "instrumentation"
    apk_target = ":$_apk_target_name"
  }

  android_apk(_apk_target_name) {
    deps = []
    data_deps = []
    forward_variables_from(invoker, "*")
    deps += [ "//testing/android/broker:broker_java" ]
    data_deps += [
      "//testing/android/driver:driver_apk",
      "//tools/android/forwarder2",
      "//tools/android/md5sum",
    ]

    run_findbugs =
        defined(invoker.run_findbugs) && invoker.run_findbugs &&
        (defined(invoker.java_files) || defined(invoker.DEPRECATED_java_in_dir))
  }

  group(target_name) {
    public_deps = [
      ":$_apk_target_name",
      ":$_test_runner_target_name",
    ]
  }
}

# Declare an Android gtest apk
#
# This target creates an Android apk for running gtest-based unittests.
#
# Variables
#   deps: Specifies the dependencies of this target. These will be passed to
#     the underlying android_apk invocation and should include the java and
#     resource dependencies of the apk.
#   unittests_dep: This should be the label of the gtest native target. This
#     target must be defined previously in the same file.
#   unittests_binary: The basename of the library produced by the unittests_dep
#     target. If unspecified, it assumes the name of the unittests_dep target
#     (which will be correct unless that target specifies an "output_name".
#     TODO(brettw) make this automatic by allowing get_target_outputs to
#     support executables.
#   apk_name: The name of the produced apk. If unspecified, it uses the name
#             of the unittests_dep target postfixed with "_apk"
#   use_default_launcher: Whether the default activity (NativeUnitTestActivity)
#     should be used for launching tests.
#
# Example
#   unittest_apk("foo_unittests_apk") {
#     deps = [ ":foo_java", ":foo_resources" ]
#     unittests_dep = ":foo_unittests"
#   }
template("unittest_apk") {
  android_apk(target_name) {
    set_sources_assignment_filter([])
    data_deps = []
    deps = []
    forward_variables_from(invoker, "*")
    testonly = true

    assert(defined(unittests_dep), "Need unittests_dep for $target_name")

    test_suite_name = get_label_info(unittests_dep, "name")

    # This trivial assert is needed in case both unittests_binary and apk_name
    # are defined, as otherwise test_suite_name would not be used.
    assert(test_suite_name != "")

    if (!defined(apk_name)) {
      apk_name = test_suite_name
    }

    if (!defined(android_manifest)) {
      android_manifest =
          "//testing/android/native_test/java/AndroidManifest.xml"
    }

    if (!defined(unittests_binary)) {
      unittests_binary = "lib${test_suite_name}${shlib_extension}"
    }

    final_apk_path = "$root_build_dir/${apk_name}_apk/${apk_name}-debug.apk"

    if (!defined(use_default_launcher) || use_default_launcher) {
      java_files = [
        "//testing/android/native_test/java/src/org/chromium/native_test/NativeBrowserTestActivity.java",
        "//testing/android/native_test/java/src/org/chromium/native_test/NativeTestActivity.java",
        "//testing/android/native_test/java/src/org/chromium/native_test/NativeUnitTestActivity.java",
        "//testing/android/native_test/java/src/org/chromium/native_test/NativeTestInstrumentationTestRunner.java",
      ]
    }
    native_libs = [ unittests_binary ]
    deps += [
      "//base:base_java",
      "//build/android/pylib/remote/device/dummy:remote_device_dummy_apk",
      "//testing/android/appurify_support:appurify_support_java",
      "//testing/android/reporter:reporter_java",
    ]
    data_deps += [ "//tools/android/md5sum" ]
    if (host_os == "linux") {
      data_deps += [ "//tools/android/forwarder2" ]
    }
  }
}

# Generate .java files from .aidl files.
#
# This target will store the .java files in a srcjar and should be included in
# an android_library or android_apk's srcjar_deps.
#
# Variables
#   sources: Paths to .aidl files to compile.
#   import_include: Path to directory containing .java files imported by the
#     .aidl files.
#   interface_file: Preprocessed aidl file to import.
#
# Example
#   android_aidl("foo_aidl") {
#     import_include = "java/src"
#     sources = [
#       "java/src/com/foo/bar/FooBarService.aidl",
#       "java/src/com/foo/bar/FooBarServiceCallback.aidl",
#     ]
#   }
template("android_aidl") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  srcjar_path = "${target_gen_dir}/${target_name}.srcjar"
  aidl_path = "${android_sdk_build_tools}/aidl"
  framework_aidl = "$android_sdk/framework.aidl"

  action(target_name) {
    script = "//build/android/gyp/aidl.py"
    sources = invoker.sources

    imports = [ framework_aidl ]
    if (defined(invoker.interface_file)) {
      assert(invoker.interface_file != "")
      imports += [ invoker.interface_file ]
    }

    inputs = [ aidl_path ] + imports

    depfile = "${target_gen_dir}/${target_name}.d"
    outputs = [
      depfile,
      srcjar_path,
    ]
    rebased_imports = rebase_path(imports, root_build_dir)
    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--aidl-path",
      rebase_path(aidl_path, root_build_dir),
      "--imports=$rebased_imports",
      "--srcjar",
      rebase_path(srcjar_path, root_build_dir),
    ]
    if (defined(invoker.import_include) && invoker.import_include != "") {
      # TODO(cjhopman): aidl supports creating a depfile. We should be able to
      # switch to constructing a depfile for the overall action from that
      # instead of having all the .java files in the include paths as inputs.
      rebased_import_includes =
          rebase_path([ invoker.import_include ], root_build_dir)
      args += [ "--includes=$rebased_import_includes" ]

      _java_files_build_rel =
          exec_script("//build/android/gyp/find.py",
                      rebase_path([ invoker.import_include ], root_build_dir),
                      "list lines")
      _java_files = rebase_path(_java_files_build_rel, ".", root_build_dir)
      inputs += _java_files
    }
    args += rebase_path(sources, root_build_dir)
  }
}

# Creates a dist directory for a native executable.
#
# Running a native executable on a device requires all the shared library
# dependencies of that executable. To make it easier to install and run such an
# executable, this will create a directory containing the native exe and all
# it's library dependencies.
#
# Note: It's usually better to package things as an APK than as a native
# executable.
#
# Variables
#   dist_dir: Directory for the exe and libraries. Everything in this directory
#     will be deleted before copying in the exe and libraries.
#   binary: Path to (stripped) executable.
#   include_main_binary: Whether |binary| should be copied to |dist_dir|.
#
# Example
#   create_native_executable_dist("foo_dist") {
#     dist_dir = "$root_build_dir/foo_dist"
#     binary = "$root_build_dir/foo"
#     deps = [ ":the_thing_that_makes_foo" ]
#   }
template("create_native_executable_dist") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  dist_dir = invoker.dist_dir
  binary = invoker.binary
  template_name = target_name

  libraries_list =
      "${target_gen_dir}/${template_name}_library_dependencies.list"

  find_deps_target_name = "${template_name}__find_library_dependencies"
  copy_target_name = "${template_name}__copy_libraries_and_exe"

  action(find_deps_target_name) {
    forward_variables_from(invoker, [ "deps" ])
    visibility = [ ":$copy_target_name" ]

    script = "//build/android/gyp/write_ordered_libraries.py"
    depfile = "$target_gen_dir/$target_name.d"
    inputs = [
      binary,
      android_readelf,
    ]
    outputs = [
      depfile,
      libraries_list,
    ]
    rebased_binaries = rebase_path([ binary ], root_build_dir)
    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--input-libraries=$rebased_binaries",
      "--libraries-dir",
      rebase_path(root_shlib_dir, root_build_dir),
      "--output",
      rebase_path(libraries_list, root_build_dir),
      "--readelf",
      rebase_path(android_readelf, root_build_dir),
    ]
  }

  copy_ex(copy_target_name) {
    visibility = [ ":$template_name" ]

    clear_dir = true

    inputs = [
      libraries_list,
    ]
    if (defined(invoker.include_main_binary) && invoker.include_main_binary) {
      inputs += [ binary ]
    }

    dest = dist_dir

    rebased_libraries_list = rebase_path(libraries_list, root_build_dir)
    args = [ "--files=@FileArg($rebased_libraries_list:lib_paths)" ]
    if (defined(invoker.include_main_binary) && invoker.include_main_binary) {
      rebased_binaries_list = rebase_path([ binary ], root_build_dir)
      args += [ "--files=$rebased_binaries_list" ]
    }

    deps = [
      ":$find_deps_target_name",
    ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }

  group(template_name) {
    forward_variables_from(invoker, [ "visibility" ])
    public_deps = [
      ":$copy_target_name",
    ]
  }
}

# Compile a protocol buffer to java.
#
# This generates java files from protocol buffers and creates an Android library
# containing the classes.
#
# Variables
#   sources: Paths to .proto files to compile.
#   proto_path: Root directory of .proto files.
#
# Example:
#  proto_java_library("foo_proto_java") {
#    proto_path = [ "src/foo" ]
#    sources = [ "$proto_path/foo.proto" ]
#  }
template("proto_java_library") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])
  _protoc_dep = "//third_party/android_protobuf:android_protoc($host_toolchain)"
  _protoc_out_dir = get_label_info(_protoc_dep, "root_out_dir")
  _protoc_bin = "$_protoc_out_dir/android_protoc"
  _proto_path = invoker.proto_path

  _template_name = target_name

  action("${_template_name}__protoc_java") {
    srcjar_path = "$target_gen_dir/$target_name.srcjar"
    script = "//build/protoc_java.py"

    deps = [
      _protoc_dep,
    ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }

    sources = invoker.sources
    depfile = "$target_gen_dir/$target_name.d"
    outputs = [
      depfile,
      srcjar_path,
    ]
    args = [
             "--depfile",
             rebase_path(depfile, root_build_dir),
             "--protoc",
             rebase_path(_protoc_bin, root_build_dir),
             "--proto-path",
             rebase_path(_proto_path, root_build_dir),
             "--srcjar",
             rebase_path(srcjar_path, root_build_dir),
           ] + rebase_path(sources, root_build_dir)
  }

  android_library(target_name) {
    java_files = []
    srcjar_deps = [ ":${_template_name}__protoc_java" ]
    deps = [
      "//third_party/android_protobuf:protobuf_nano_javalib",
    ]
  }
}
