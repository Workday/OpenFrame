{
  "_description" : "This file contains info about our performance test traces, used by the perf dashboard (http://chromeperf.appspot.com). Links in test descriptions should be in markdown format. SUITE as the description means the same description as the test suite.",

  "score": {
    "description": "SUITE"
  },

  "Score": {
    "description": "SUITE"
  },

  "Total": {
    "description": "SUITE"
  },

  "ImageDecoding_avg": {
    "description": "Average decode time of 4 images formats: gif, png, jpg, and webp."
  },
  "image_decoding.html?gif": {
    "description": "Time to decode a 3.1 MB, 2560x1920 gif image.  File found at chrome/test/data/image_decoding/droids.gif"
  },
  "image_decoding.html?jpg": {
    "description": "Time to decode a 810 KB, 2560x1920 jpg image.  File found at chrome/test/data/image_decoding/droids.jpg"
  },
  "image_decoding.html?png": {
    "description": "Time to decode a 4.6 MB, 2560x1920 png image.  File found at chrome/test/data/image_decoding/droids.png"
  },
  "image_decoding.html?webp": {
    "description": "Time to decode a 65 KB, 2560x1920 webp image.  File found at chrome/test/data/image_decoding/droids.webp"
  },
  "ai-astar": {
    "description": "This benchmark uses the [A* search algorithm](http://en.wikipedia.org/wiki/A*_search_algorithm) to automatically plot an efficient path between two points, in the presence of obstacles. Adapted from code by [Brian Gringstead](http://www.briangrinstead.com/blog/astar-search-algorithm-in-javascript)."
  },
  "audio-beat-detection": {
    "description": "This benchmark performs [beat detection](http://en.wikipedia.org/wiki/Beat_detection) on an Audio sample using [code](http://beatdetektor.svn.sourceforge.net/viewvc/beatdetektor/trunk/core/js/beatdetektor.js?revision=18&view=markup) from [BeatDetektor](http://www.cubicproductions.com/index.php?option=com_content&view=article&id=67&Itemid=82) and [DSP.js](http://github.com/corbanbrook/dsp.js/)."
  },
  "audio-dft": {
    "description": "This benchmark performs a [Discrete Fourier Transform](http://en.wikipedia.org/wiki/Discrete_Fourier_transform) on an Audio sample using code from [DSP.js](http://github.com/corbanbrook/dsp.js)."
  },
  "audio-fft": {
    "description": "This benchmark performs a [Fast Fourier Transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform) on an Audio sample using code from [DSP.js](http://github.com/corbanbrook/dsp.js/)."
  },
  "audio-oscillator": {
    "description": "This benchmark generates a soundwave using code from [DSP.js](http://github.com/corbanbrook/dsp.js/)."
  },
  "imaging-darkroom": {
    "description": "This benchmark performs a variety of photo manipulations such as Fill, Brightness, Contrast, Saturation, and Temperature."
  },
  "imaging-desaturate": {
    "description": "This benchmark [desaturates](http://en.wikipedia.org/wiki/Colorfulness) a photo using code from [Pixastic](http://www.pixastic.com/)."
  },
  "imaging-gaussian-blur": {
    "description": "This benchmark performs a [Gaussian blur](http://en.wikipedia.org/wiki/Gaussian_blur) on a photo."
  },
  "json-parse-financial": {
    "description": "This benchmark parses [JSON](http://www.json.org) records."
  },
  "json-stringify-tinderbox": {
    "description": "This benchmark serializes [Tinderbox](http://tests.themasta.com/tinderboxpushlog/?tree=Firefox) build data to [JSON](http://www.json.org)."
  },

  "CodeLoad": {
    "description": "measures how quickly a JavaScript engine can start executing code after loading a large JavaScript program, social widget being a common example. The source for test is derived from open source libraries (Closure, jQuery) (1,530 lines)."
  },
  "Crypto": {
    "description": "Encryption and decryption benchmark based on code by Tom Wu (1698 lines)."
  },
  "DeltaBlue": {
    "description": "One-way constraint solver, originally written in Smalltalk by John Maloney and Mario Wolczko (880 lines)."
  },
  "EarleyBoyer": {
    "description": "Classic Scheme benchmarks, translated to JavaScript by Florian Loitsch's Scheme2Js compiler (4684 lines)."
  },
  "Gameboy": {
    "description": "Emulate the portable console's architecture and runs a demanding 3D simulation, all in JavaScript (11,097 lines)."
  },
  "Mandreel": {
    "description": "Runs the 3D Bullet Physics Engine ported from C++ to JavaScript via Mandreel (277,377 lines)."
  },
  "NavierStokes": {
    "description": "2D NavierStokes equations solver, heavily manipulates double precision arrays. Based on Oliver Hunt's code (387 lines)."
  },
  "PdfJS": {
    "description": "Mozilla's PDF Reader implemented in JavaScript. It measures decoding and interpretation time (33,056 lines)."
  },
  "RayTrace": {
    "description": "Ray tracer benchmark based on code by Adam Burmister (904 lines)."
  },
  "RegExp": {
    "description": "Regular expression benchmark generated by extracting regular expression operations from 50 of the most popular web pages (1761 lines)."
  },
  "Richards": {
    "description": "OS kernel simulation benchmark, originally written in BCPL by Martin Richards (539 lines)."
  },
  "Splay": {
    "description": "Data manipulation benchmark that deals with splay trees and exercises the automatic memory management subsystem (394 lines).."
  },

  "commit_charge": {
    "description": "System commit charge (commited memory pages)"
  },
  "page_load_time": {
    "description": "Average page load time. Measured from navigationStart until the completion time of a layout after the window.load event."
  },
  "processes": {
    "description": "Number of processes used by chrome"
  },
  "read_bytes_browser": {
    "description": "Number of IO bytes read by the browser process"
  },
  "read_bytes_renderer": {
    "description": "Number of IO bytes read by the renderer process"
  },
  "read_operations_browser": {
    "description": "Number of IO read operations by the browser process"
  },
  "read_operations_renderer": {
    "description": "Number of IO read operations by the renderer process"
  },
  "resident_set_size_peak_size_browser": {
    "description": "The peak Resident Set Size (physically resident memory) usage achieved by the browser process."
  },
  "resident_set_size_peak_size_renderer": {
    "description": "The peak Resident Set Size (physically resident memory) usage achieved by the renderer process."
  },
  "V8.MemoryExternalFragmentationTotal": {
    "description": "Total external memory fragmentation after each GC in percent."
  },
  "V8.MemoryHeapSampleTotalCommitted": {
    "description": "The total size of committed memory used by V8 after each GC in KB."
  },
  "V8.MemoryHeapSampleTotalUsed": {
    "description": "The total size of live memory used by V8 after each GC in KB."
  },
  "vm_final_size_browser": {
    "description": "Virtual Memory Size (address space allocated) of browser process"
  },
  "vm_final_size_gpu": {
    "description": "Virtual Memory Size (address space allocated) of renderer process"
  },
  "vm_final_size_renderer": {
    "description": "Virtual Memory Size (address space allocated) of renderer process"
  },
  "vm_final_size_total": {
    "description": "Virtual Memory Size (address space allocated) of GPU process"
  },
  "vm_peak_size_browser": {
    "description": "The peak Virtual Memory Size (address space allocated) usage achieved by the browser process."
  },
  "vm_peak_size_renderer": {
    "description": "The peak Virtual Memory Size (address space allocated) usage achieved by the renderer process."
  },
  "vm_private_dirty_final_browser": {
    "description": "Private Dirty is basically the amount of RAM inside the process that can not be paged to disk (it is not backed by the same data on disk), and is not shared with any other processes. Another way to look at this is the RAM that will become available to the system when that process goes away (and probably quickly subsumed into caches and other uses of it)."
  },
  "vm_private_dirty_final_renderer": {
    "description": "Private Dirty is basically the amount of RAM inside the process that can not be paged to disk (it is not backed by the same data on disk), and is not shared with any other processes. Another way to look at this is the RAM that will become available to the system when that process goes away (and probably quickly subsumed into caches and other uses of it)."
  },
  "vm_private_dirty_final_total": {
    "description": "Private Dirty is basically the amount of RAM inside the process that can not be paged to disk (it is not backed by the same data on disk), and is not shared with any other processes. Another way to look at this is the RAM that will become available to the system when that process goes away (and probably quickly subsumed into caches and other uses of it)."
  },
  "vm_proportional_set_size_final_browser": {
    "description": "The PSS number is a metric the kernel computes that takes into account memory sharing -- basically each page of RAM in a process is scaled by a ratio of the number of other processes also using that page. This way you can (in theory) add up the pss across all processes to see the total RAM they are using, and compare pss between processes to get a rough idea of their relative weight."
  },
  "vm_proportional_set_size_final_renderer": {
    "description": "The PSS number is a metric the kernel computes that takes into account memory sharing -- basically each page of RAM in a process is scaled by a ratio of the number of other processes also using that page. This way you can (in theory) add up the pss across all processes to see the total RAM they are using, and compare pss between processes to get a rough idea of their relative weight."
  },
  "vm_proportional_set_size_final_total": {
    "description": "The PSS number is a metric the kernel computes that takes into account memory sharing -- basically each page of RAM in a process is scaled by a ratio of the number of other processes also using that page. This way you can (in theory) add up the pss across all processes to see the total RAM they are using, and compare pss between processes to get a rough idea of their relative weight."
  },
  "vm_resident_set_size_final_size_browser": {
    "description": "Resident Set Size (physically resident memory) of browser process"
  },
  "vm_resident_set_size_final_size_gpu": {
    "description": "Resident Set Size (physically resident memory) of GPU process"
  },
  "vm_resident_set_size_final_size_renderer": {
    "description": "Resident Set Size (physically resident memory) of renderer process"
  },
  "vm_resident_set_size_final_size_total": {
    "description": "Resident Set Size (physically resident memory) of all processes"
  },
  "vm_working_set_final_size_browser": {
    "description": "Working Set size of browser process"
  },
  "vm_working_set_final_size_renderer": {
    "description": "Working Set size of renderer process"
  },
  "vm_working_set_final_size_total": {
    "description": "Working Set size of all processes"
  },
  "working_set_peak_size_browser": {
    "description": "The peak Working Set Size usage achieved by the browser process."
  },
  "working_set_peak_size_renderer": {
    "description": "The peak Working Set Size usage achieved by the renderer process."
  },
  "write_bytes_browser": {
    "description": "Number of IO bytes written by the browser process"
  },
  "write_bytes_renderer": {
    "description": "Number of IO bytes written by the renderer process"
  },
  "write_operations_browser": {
    "description": "Number of write IO operations by browser process"
  },
  "write_operations_renderer": {
    "description": "Number of write IO operations by renderer process"
  },

  "average_commit_time": {
    "description": "Time spent pushing the layer tree from the main thread to the compositor thread.  Is zero if software rendering."
  },
  "average_latency": {
    "description": "The average latency between input event and corresponding swap to screen."
  },
  "average_num_layers_drawn": {
    "description": "Number of layers in the tree at draw time.  Is zero in software mode."
  },
  "avg_surface_fps": {
    "description": "Average frames per second as measured by the platform's SurfaceFlinger."
  },
  "dropped_percent": {
    "description": "Number of frames that missed vsync.  The metric is slightly different in each rendering mode but roughly approximates how janky the page was."
  },
  "mean_frame_time": {
    "description": "The frame rate, but reported as an interval."
  },
  "percent_impl_scrolled": {
    "description": "The percent of input events that caused fast scrolling on the impl thread.  If you see numbers between 0 and 100, it's probably because the page changed halfway through and became slow scrolling, or vice versa."
  },
  "texture_upload_count": {
    "description": "The number of textures uploaded to the GPU."
  },
  "total_texture_upload_time": {
    "description": "The time spent in texture upload on the GPU process."
  },

  "canvasDrawImageFullClear": {
    "description": "Using a canvas element to render.  Bitmaps are blitted to the canvas using the 'drawImage' function and the canvas is fully cleared at the beginning of each frame."
  },
  "canvasDrawImageFullClearAlign": {
    "description": "Same as canvasDrawImageFullClear except all 'x' and 'y' values are roudned to the nearest integer.  This can be more efficient on translate on certain browsers."
  },
  "canvasDrawImagePartialClear": {
    "description": "Using a canvas element to render.  Bitmaps are blitted to the canvas using the 'drawImage' function and pixels drawn in the last frame are cleared to the clear color at the beginning of each frame.  This is generally slower on hardware accelerated implementations, but sometimes faster on CPU-based implementations."
  },
  "canvasDrawImagePartialClearAlign": {
    "description": "Same as canvasDrawImageFullClearAlign but only partially clearing the canvas each frame."
  },
  "css2dBackground": {
    "description": "Using div elements that have a background image specified using CSS styles.  These div elements are translated, scaled, and rotated using CSS-2D transforms."
  },
  "css2dImg": {
    "description": "Same as css2dBackground, but using img elements instead of div elements."
  },
  "css3dBackground": {
    "description": "Same as css2dBackground, but using CSS-3D transforms."
  },
  "css3dImg": {
    "description": "Same as css2dImage but using CSS-3D tranforms."
  },

  "3d-cube": {
    "description": "Pure JavaScript computations of the kind you might use to do 3d rendering, but without the rendering. This ends up mostly hitting floating point math and array access."
  },
  "3d-morph": {
    "description": "Pure JavaScript computations of the kind you might use to do 3d rendering, but without the rendering. This ends up mostly hitting floating point math and array access."
  },
  "3d-raytrace": {
    "description": "Pure JavaScript computations of the kind you might use to do 3d rendering, but without the rendering. This ends up mostly hitting floating point math and array access."
  },
  "access-binary-trees": {
    "description": "Array, object property and variable access."
  },
  "access-fannkuch": {
    "description": "Array, object property and variable access."
  },
  "access-nbody": {
    "description": "Array, object property and variable access."
  },
  "access-nsieve": {
    "description": "Array, object property and variable access."
  },
  "bitops-3bit-bits-in-byte": {
    "description": "Bitwise operations, these can be useful for various things including games, mathematical computations, and various kinds of encoding/decoding. It's also the only kind of math in JavaScript that is done as integer, not floating point."
  },
  "bitops-bits-in-byte": {
    "description": "Bitwise operations, these can be useful for various things including games, mathematical computations, and various kinds of encoding/decoding. It's also the only kind of math in JavaScript that is done as integer, not floating point."
  },
  "bitops-bitwise-and": {
    "description": "Bitwise operations, these can be useful for various things including games, mathematical computations, and various kinds of encoding/decoding. It's also the only kind of math in JavaScript that is done as integer, not floating point."
  },
  "bitops-nsieve-bits": {
    "description": "Bitwise operations, these can be useful for various things including games, mathematical computations, and various kinds of encoding/decoding. It's also the only kind of math in JavaScript that is done as integer, not floating point."
  },
  "controlflow-recursive": {
    "description": "Control flow constructs (looping, recursion, conditionals). Right now it mostly covers recursion, as the others are pretty well covered by other tests."
  },
  "crypto-aes": {
    "description": "Real cryptography code, mostly covers bitwise operations and string operations."
  },
  "crypto-md5": {
    "description": "Real cryptography code, mostly covers bitwise operations and string operations."
  },
  "crypto-sha1": {
    "description": "Real cryptography code, mostly covers bitwise operations and string operations."
  },
  "date-format-tofte": {
    "description": "Performance of JavaScript's 'date' objects."
  },
  "date-format-xparb": {
    "description": "Performance of JavaScript's 'date' objects."
  },
  "math-cordic": {
    "description": "Various mathematical type computations."
  },
  "math-partial-sums": {
    "description": "Various mathematical type computations."
  },
  "math-spectral-norm": {
    "description": "Various mathematical type computations."
  },
  "regexp-dna": {
    "description": "Regular expressions performance"
  },
  "string-base64": {
    "description": "String processing, including code to generate a giant 'tagcloud', extracting compressed JS code, etc."
  },
  "string-fasta": {
    "description": "String processing, including code to generate a giant 'tagcloud', extracting compressed JS code, etc."
  },
  "string-tagcloud": {
    "description": "String processing, including code to generate a giant 'tagcloud', extracting compressed JS code, etc."
  },
  "string-unpack-code": {
    "description": "String processing, including code to generate a giant 'tagcloud', extracting compressed JS code, etc."
  },
  "string-validate-input": {
    "description": "String processing, including code to generate a giant 'tagcloud', extracting compressed JS code, etc."
  }
}
